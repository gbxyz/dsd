#!/usr/bin/perl
# Copyright 2014 CentralNic Ltd. This program is free software; you can
# redistribute it and/or modify it under the same terms as Perl itself.
use Config::Simple;
use Data::Dumper;
use File::Temp qw(tempfile);
use Getopt::Long;
use JSON;
use Net::DNS::Packet;
use Net::Pcap;
use NetPacket::Ethernet qw(:strip ETH_TYPE_IP ETH_TYPE_IPv6);
use NetPacket::IP qw(:strip :protos);
use NetPacket::IPv6 qw(:strip);
use NetPacket::TCP qw(:strip);
use NetPacket::UDP qw(:strip);
use Pod::Usage;
use POSIX;
use Sys::Hostname;
use Sys::Syslog qw(:standard :macros);
use Time::HiRes qw(time ualarm);
use strict;

openlog('dsd', 'ndelay,perror,pid', LOG_DAEMON);

my $file = '/etc/dsd.conf';
my $foreground;
my $debug;
my $help;
GetOptions(
	'config=s'   => \$file,
	'foreground' => \$foreground,
	'debug'      => \$debug,
	'help'       => \$help,
);

pod2usage('-verbose' => 99, '-sections' => 'USAGE|OPTIONS') if ($help);

$foreground = $foreground || $debug;

my $config = Config::Simple->new($file)->hashref;

check_config($config) || die("Bad config");

syslog(LOG_DEBUG, "capturing packets on $config->{'dsd.interface'}") if ($debug);
my ($network, $mask, $error);
die($error) unless (0 == Net::Pcap::lookupnet($config->{'dsd.interface'}, \$network, \$mask, \$error));

die($error) unless (my $pcap = Net::Pcap::open_live($config->{'dsd.interface'}, 1500, 0, 1000, \$error));

my $fstr = "src port 53";
syslog(LOG_DEBUG, $fstr) if ($debug);

my $filter;
Net::Pcap::compile($pcap, \$filter, $fstr, 1, 0);
Net::Pcap::setfilter($pcap, $filter);

my $stats = { 'start' => time() };
init_stats();

my $counter = 0;

$SIG{'HUP'} = \&hup_handler;

$SIG{'ALRM'} = \&alrm_handler;
ualarm($config->{'dsd.interval'} * 1000 * 1000);

unless ($foreground) {
	syslog(LOG_DEBUG, "daemonising") if ($debug);
	if (fork() > 0) {
		exit(0);

	} else {
		setsid();
		chdir('/');
		$0 = '[dsd]';

	}
}

syslog(LOG_DEBUG, "entering loop") if ($debug);
Net::Pcap::loop($pcap, -1, \&process_packet, undef);

sub process_packet {
	my (undef, $header, $data) = @_;

	$counter++;
	return unless (0 == $counter % $config->{'dsd.sample'});

	my $eth = NetPacket::Ethernet->decode($data);
	return if (!defined($eth));

	my ($ip, $family);
	if ($eth->{type} eq ETH_TYPE_IP) {
		$family = 4;
		$ip = NetPacket::IP->decode(eth_strip($data));

	} elsif ($eth->{type} eq ETH_TYPE_IPv6) {
		$family = 6;
		$ip = NetPacket::IPv6->decode(eth_strip($data));

	} else {
		return;

	}

	my ($dns, $proto);
	if ($ip->{proto} == IP_PROTO_TCP) {
		my $tcp = NetPacket::TCP->decode($ip->{data});
		return if (!defined($tcp));

		# the first two bytes encode the packet length, remove:
		my $data = substr($tcp->{data}, 2);

		$dns = Net::DNS::Packet->new(\$data);

		$proto = 'tcp';

	} elsif ($ip->{proto} == IP_PROTO_UDP) {
		my $udp = NetPacket::UDP->decode($ip->{data});
		return if (!defined($udp));

		$dns = Net::DNS::Packet->new(\$udp->{data});

		$proto = 'udp';

	}

	return if (!defined($dns));

	my $q = ($dns->question)[0];
	syslog(LOG_DEBUG, $q->string) if ($debug);
	my $zone = (
		reverse
		sort { length($a) <=> length($b) }
		grep { lc($_) eq lc($q->qname) || $q->qname =~ /\.$_$/i }
		get_zones()
	)[0] || 'other';

	$stats->{'zones'}->{$zone}->{'queries'}                       += $config->{'dsd.sample'};
	$stats->{'zones'}->{$zone}->{'families'}->{$family}           += $config->{'dsd.sample'};
	$stats->{'zones'}->{$zone}->{'protos'}->{$proto}              += $config->{'dsd.sample'};
	$stats->{'zones'}->{$zone}->{'rcodes'}->{$dns->header->rcode} += $config->{'dsd.sample'};
}

sub alrm_handler {
	syslog(LOG_DEBUG, "ALRM received") if ($debug);

	$stats->{'end'} = time();

	map { syslog(LOG_DEBUG, $_) } split(/\n/, Dumper($stats)) if ($debug);

	my $data = JSON->new->pretty->encode($stats);

	map { syslog(LOG_DEBUG, $_) } split(/\n/, $data) if ($debug);

	my ($fh, $file) = tempfile('SUFFIX' => '.js');
	$fh->print($data);
	$fh->close;

	my @cmd = (
		'scp',
		'-q',
		'-i', $config->{'dsd.ssh_key'},
		$file,
		sprintf('%s@%s:%s', $config->{'dsd.ssh_user'}, $config->{'dsd.ssh_server'}, ($config->{'dsd.ssh_directory'} ne '' ? $config->{'dsd.ssh_directory'}.'/' : '')),
	);
	syslog(LOG_DEBUG, join(' ', @cmd)) if ($debug);

	system(@cmd);
	my $code = $? >> 8;
	if ($code > 0) {
		syslog(LOG_CRIT, "Failed to submit stats (code $code)");

	} else {
		init_stats();

	}

	unlink($file);

	ualarm($config->{'dsd.interval'} * 1000 * 1000);
}

sub hup_handler {
	syslog(LOG_DEBUG, "HUP received") if ($debug);
	my $new = Config::Simple->new($file)->hashref;
	if (!check_config($new)) {
		syslog(LOG_CRIT, "Configuration is invalid");

	} else {
		syslog(LOG_WARNING, "Warning: interface has changed, please restart the daemon") if ($new->{'dsd.interface'} ne $config->{'dsd.interface'});

		$config = $new;
		syslog(LOG_INFO, "Config reloaded from $file");

	}
}

sub check_config {
	my $config = shift;
	return (
		(int($config->{'dsd.interval'}) eq $config->{'dsd.interval'} && $config->{'dsd.interval'}  > 0) &&
		(int($config->{'dsd.sample'})   eq $config->{'dsd.sample'}   && $config->{'dsd.sample'} > 0) &&
		(defined($config->{'dsd.zones'})) &&
		(length($config->{'dsd.ssh_server'}) > 0) &&
		(length($config->{'dsd.ssh_user'}) > 0) &&
		(length($config->{'dsd.ssh_key'}) > 0) &&
		(!defined($config->{'dsd.ssh_directory'}) || length($config->{'dsd.ssh_directory'}) > 0)
	);
}

sub init_stats {
	$stats = {
		'start' => time(),
		'host' => hostname(),
	};
}

sub get_zones {
	return (ref($config->{'dsd.zones'}) eq 'ARRAY' ? @{$config->{'dsd.zones'}} : split(',', $config->{'dsd.zones'}));
}

__END__

=head1 NAME

DSD - a simple DNS Statistics collecting Daemon

=head1 DESCRIPTION

DSD is a simple system for capturing and aggregating statistical information
about DNS servers. It is somewhat similar to DSC, but is a great deal simpler.

DSD consists of two parts: The C<dsd> script runs on the DNS server, captures
packets using C<Net::Pcap>, disassembles them using C<NetPacket>, and analyses
them using C<Net::DNS>. Every now and then, it will serialise its data into a
blob of JSON and copy it to a remote server.

A separate script (which does not currently exist) then imports the data in the
JSON files into a database. The data is then used by a number of Munin plugins
(which also do not currently exist) which present the data to the user.

=head1 USAGE

	dsd [OPTIONS]

=head1 OPTIONS

=over

=item --config=FILE

Specify config file. Defaults to /etc/dsd/dsd.conf

=item --foreground

Don't daemonise.

=item --debug

Enable debugging. Implies --foreground

=item --help

Show help

=back

=head1 CONFIGURATION FILE

	[dsd]
	; interface to capture packets on
	interface=eth0

	; capture 1/sample packets
	sample=1

	; submit data every interval seconds
	interval=300

	; list of zones you're interested in
	zones="foo,bar"

	; server to submit stats to
	ssh_server=example.com

	; SSH username
	ssh_user=example

	; SSH private key
	ssh_key=/home/example/.ssh/id_rsa

	; directory (optional)
	ssh_directory=/var/tmp/dsd

=head1 SEE ALSO

=over

=item L<https://www.centralnic.com/>

=item L<http://www.net-dns.org/>

=item L<http://dns.measurement-factory.com/tools/dsc/>

=item L<http://munin-monitoring.org/>

=back

=head1 COPYRIGHT

dsd is Copyright 2014 CentralNic Ltd. All rights reserved. This program is free
software; you can redistribute it and/or modify it under the same terms as Perl
itself.

=cut
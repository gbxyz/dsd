#!/usr/bin/perl
# Copyright 2014 CentralNic Ltd. This program is free software; you can
# redistribute it and/or modify it under the same terms as Perl itself.
use Config::Simple;
use Getopt::Long;
use HTTP::Request::Common;
use JSON;
use LWP::UserAgent;
use Net::DNS::Packet;
use Net::Pcap;
use NetPacket::Ethernet qw(:strip ETH_TYPE_IP ETH_TYPE_IPv6);
use NetPacket::IP qw(:strip :protos);
use NetPacket::IPv6 qw(:strip);
use NetPacket::TCP qw(:strip);
use NetPacket::UDP qw(:strip);
use POSIX;
use Sys::Syslog qw(:standard :macros);
use Time::HiRes qw(time ualarm);
use strict;

my $file = '/etc/dsd.conf';
my $device = 'eth0';
my $foreground = undef;
GetOptions(
	'config=s'   => \$file,
	'foreground' => \$foreground,
	'device'     => \$device,
);

my $config = Config::Simple->new($file)->hashref;

check_config($config) || die("Bad config");

my ($network, $mask, $error);
die($error) unless (0 == Net::Pcap::lookupnet($device, \$network, \$mask, \$error));

die($error) unless (my $pcap = Net::Pcap::open_live($device, 1500, 0, 1000, \$error));

my $filter;
Net::Pcap::compile($pcap, \$filter, "src port 53", 1, 0);
Net::Pcap::setfilter($pcap, $filter);

my $stats = { 'start' => time() };

my $counter = 0;

openlog('dsd', 'ndelay,perror,pid', LOG_DAEMON);

my $ua = LWP::UserAgent->new;

$SIG{'HUP'} = \&hup_handler;

$SIG{'ALRM'} = \&alrm_handler;
ualarm($config->{'dsd.interval'} * 1000 * 1000);

unless ($foreground) {
	if (fork() > 0) {
		exit(0);

	} else {
		setsid();
		chdir('/');
		$0 = '[dsd]';

	}
}

Net::Pcap::loop($pcap, -1, \&process_packet, undef);

sub process_packet {
	my (undef, $header, $data) = @_;

	$counter++;
	return unless (0 == $counter % $config->{'dsd.sample'});

	my $eth = NetPacket::Ethernet->decode($data);
	return if (!defined($eth));

	my ($ip, $family);
	if ($eth->{type} eq ETH_TYPE_IP) {
		$family = 4;
		$ip = NetPacket::IP->decode(eth_strip($data));

	} elsif ($eth->{type} eq ETH_TYPE_IPv6) {
		$family = 6;
		$ip = NetPacket::IPv6->decode(eth_strip($data));

	} else {
		return;

	}

	my ($dns, $proto);
	if ($ip->{proto} == IP_PROTO_TCP) {
		my $tcp = NetPacket::TCP->decode($ip->{data});
		return if (!defined($tcp));

		# the first two bytes encode the packet length, remove:
		my $data = substr($tcp->{data}, 2);

		$dns = Net::DNS::Packet->new(\$data);

		$proto = 'tcp';

	} elsif ($ip->{proto} == IP_PROTO_UDP) {
		my $udp = NetPacket::UDP->decode($ip->{data});
		return if (!defined($udp));

		$dns = Net::DNS::Packet->new(\$udp->{data});

		$proto = 'udp';

	}

	return if (!defined($dns));

	my $q = ($dns->question)[0];
	my $zone = (
		reverse
		sort { length($a) <=> length($b) }
		grep { lc($_) eq lc($q->qname) || $q->qname =~ /\.$_$/i }
		(ref($config->{'dsd.zones'}) eq 'ARRAY' ? @{$config->{'dsd.zones'}} : split(',', $config->{'dsd.zones'}))
	)[0] || 'other';

	$stats->{'zones'}->{$zone}->{'queries'}                       += $config->{'dsd.sample'};
	$stats->{'zones'}->{$zone}->{'families'}->{$family}           += $config->{'dsd.sample'};
	$stats->{'zones'}->{$zone}->{'protos'}->{$proto}              += $config->{'dsd.sample'};
	$stats->{'zones'}->{$zone}->{'rcodes'}->{$dns->header->rcode} += $config->{'dsd.sample'};
}

sub alrm_handler {
	$stats->{'end'} = time();

	my $res = $ua->request(POST($config->{'dsd.url'}, 'Content' => to_json($stats), 'Content_Type' => 'application/json'));
	if ($res->is_success) {
		$stats = { 'start' => time() };
		ualarm($config->{'dsd.interval'} * 1000 * 1000);

	} else {
		syslog(LOG_ERR, sprintf("Error posting to %s: %s", $config->{'dsd.submit_url'}, $res->status_line));

	}
}

sub hup_handler {
	my $new = Config::Simple->new($file)->hashref;
	if (!check_config($new)) {
		syslog(LOG_CRIT, "Configuration is invalid");

	} else {
		$config = $new;
		syslog(LOG_INFO, "Config reloaded from $file");

	}
}

sub check_config {
	my $config = shift;

	return (
		(int($config->{'dsd.interval'}) eq $config->{'dsd.interval'} && $config->{'dsd.interval'}  > 0) &&
		(int($config->{'dsd.sample'})   eq $config->{'dsd.sample'}   && $config->{'dsd.sample'} > 0) &&
		(defined($config->{'dsd.zones'})) &&
		(length($config->{'dsd.url'}) > 0)
	);
}